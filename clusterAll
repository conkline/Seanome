#!/bin/bash
#
# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html
#
# ARG_OPTIONAL_SINGLE([in],[i],[name of input directory containing raw reads])
# ARG_OPTIONAL_SINGLE([out],[o],[name of directory containing indexed reads])
# ARG_OPTIONAL_SINGLE([threads],[t],[number of threads to run in parellel (default: # available)])
# ARG_OPTIONAL_SINGLE([mindepth],[m],[minimum reads per locus, per sample],[3])
# ARG_OPTIONAL_SINGLE([clusterid],[c],[global clustering threshold],[.95])
# ARG_OPTIONAL_SINGLE([minlength],[l],[minimum alignment length],[80])
# ARG_OPTIONAL_SINGLE([maxdiffs],[d],[maximum substitutions, insertions, or deletions in alignment],[10])
# ARG_HELP([The general script's help msg])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


# # When called, the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option()
{
	local first_option all_short_options='ipmtqbcldnh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_in=""
_arg_out=""
_arg_threads=$(nproc)
_arg_clusterid=.95
_arg_minlength=80
_arg_maxdiffs=10
_arg_mindp=3
_arg_maxdp=""
_arg_minper=3 
_arg_mincc=.95
_arg_mincount=2
_arg_mindepth=6
_arg_minsamples=1
_arg_maxmm=.15
_arg_ploidy=2

# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help()
{
	printf '%s\n' "Seanome clusterAll"
	printf 'Usage: %s [-i|--in <arg>] [-o|--out <arg>] [-t|--threads <arg>] [--c2 <arg>] [-a|--alignlength <arg>] [-d|--maxdiffs <arg>] [--ploidy <arg>] [--min-depth <arg>] [--max-depth <arg>] [--min-per-sample <arg>] [--min-cc <arg>] [--max-mm <arg>] [--min-count <arg>] [--min-cov <arg>] [--min-samples <arg>] [-h|--help]\n' "$0"
	printf '\t%s\n' "-i, --in: name of input directory containing raw reads (no default)"
	printf '\t%s\n' "-o, --out: name of directory containing folders with indexed reads (no default)"
	printf '\t%s\n' "-t, --threads: number of threads to run in parellel (default: # available)"
	printf '\t%s\n\n' "-h, --help: Prints help"
	
	printf '\t%s\n' "Assembly building parameters"
	printf '\t%s\n' "--c2: global clustering threshold (default: '0.95')"
	printf '\t%s\n' "-a, --alignlength: minimum alignment length (default: '80')"
	printf '\t%s\n' "-d, --maxdiffs: maximum substitutions, insertions, or deletions in alignment (default: '10')"
	printf '\t%s\n\n' "--ploidy: organism ploidy (expected # haplotypes per individual) (default: '2')"
	
	printf '\t%s\n' "Assembly filtering parameters"
	printf '\t%s\n' "--min-depth: minimum number of reads per locus (default: '3')"
	printf '\t%s\n' "--max-depth: maximum number of reads per locus (default: if no hard cutoff specified, Seanome will determine one using head-tail clustering)"
	printf '\t%s\n' "--min-per-sample: minimum number of reads per locus, per sample (default: '3')"
	printf '\t%s\n' "--min-cc: minimum average % column conservation (default: '0.95')"
	printf '\t%s\n\n' "--max-mm: maximum % mismatch (default: '0.15')"
	
	printf '\t%s\n' "SNP calling parameters"
	printf '\t%s\n' "--min-count: minimum minor allele count (default: '2')"
	printf '\t%s\n' "--min-cov: minimum coverage (default: '6')"
	printf '\t%s\n' "--min-samples: minimum samples per SNP (default: '1')"
	
}


# The parsing of the command-line
parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			# We support whitespace as a delimiter between option argument and its value.
			# Therefore, we expect the --in or -i value.
			# so we watch for --in and -i.
			# Since we know that we got the long or short option,
			# we just reach out for the next argument to get the value.
			-i|--in)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_in="$2"
				shift
				;;
			# We support the = as a delimiter between option argument and its value.
			# Therefore, we expect --in=value, so we watch for --in=*
			# For whatever we get, we strip '--in=' using the ${var##--in=} notation
			# to get the argument value
			--in=*)
				_arg_in="${_key##--in=}"
				;;
			# We support getopts-style short arguments grouping,
			# so as -i accepts value, we allow it to be appended to it, so we watch for -i*
			# and we strip the leading -i from the argument string using the ${var##-i} notation.
			-i*)
				_arg_in="${_key##-i}"
				;;
			# See the comment of option '--in' to see what's going on here - principle is the same.
			-o|--out)
				test $# -lt 2 && die "Missing value for the argument '$_key'." 1
				_arg_out="$2"
				shift
				;;
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--out=*)
				_arg_out="${_key##--out=}"
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			-o*)
				_arg_out="${_key##-o}"
				;;
			# See the comment of option '--in' to see what's going on here - principle is the same.
			-t|--threads)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_threads="$2"
				shift
				;;
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--threads=*)
				_arg_threads="${_key##--threads=}"
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			-t*)
				_arg_threads="${_key##-t}"
				;;
			# See the comment of option '--in' to see what's going on here - principle is the same.
			--min-depth)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1 
				_arg_mindp="$2"
				shift
				;;																			                        
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--min-depth=*)
				_arg_mindp="${_key##--min-depth=}"
				;;
      # See the comment of option '--in' to see what's going on here - principle is the same.
			--max-depth)
				 test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				 _arg_maxdp="$2"
	       shift
	       ;;                                                                                                                       # See the comment of option '--in=' to see what's going on here - principle is the same.
			--max-depth=*)
				_arg_maxdp="${_key##--max-depth=}"
				;;
      # See the comment of option '--in' to see what's going on here - principle is the same.
			--min-per-sample)
				 test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				 _arg_minper="$2"
	       shift
	       ;;                                                                                                                       # See the comment of option '--in=' to see what's going on here - principle is the same.
			--min-per-sample=*)
				_arg_minper="${_key##--min-per-sample=}"
				;;				
      # See the comment of option '--in' to see what's going on here - principle is the same.
			--min-cc)
				 test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				 _arg_mincc="$2"
	       shift
	       ;;                                                                                                                       # See the comment of option '--in=' to see what's going on here - principle is the same.
			--min-cc=*)
				_arg_mincc="${_key##--min-cc=}"
				;;					
      # See the comment of option '--in' to see what's going on here - principle is the same.
			--max-mm)
				 test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				 _arg_maxmm="$2"
	       shift
	       ;;                                                                                                                       # See the comment of option '--in=' to see what's going on here - principle is the same.
			--max-mm=*)
				_arg_maxmm="${_key##--max-mm=}"
				;;				
      # See the comment of option '--in' to see what's going on here - principle is the same.
			--ploidy)
				 test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				 _arg_ploidy="$2"
	       shift
	       ;;                                                                                                                       # See the comment of option '--in=' to see what's going on here - principle is the same.
			--ploidy=*)
				_arg_ploidy="${_key##--ploidy=}"
				;;					
      # See the comment of option '--in' to see what's going on here - principle is the same.
			--min-count)
				 test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				 _arg_mincount="$2"
	       shift
	       ;;                                                                                                                       # See the comment of option '--in=' to see what's going on here - principle is the same.
			--min-count=*)
				_arg_mincount="${_key##--min-count=}"
				;;				
      # See the comment of option '--in' to see what's going on here - principle is the same.
			--min-cov)
				 test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				 _arg_mindepth="$2"
	       shift
	       ;;                                                                                                                       # See the comment of option '--in=' to see what's going on here - principle is the same.
			--min-cov=*)
				_arg_mindepth="${_key##--min-cov=}"
				;;				
      # See the comment of option '--in' to see what's going on here - principle is the same.
			--min-samples)
				 test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				 _arg_minsamples="$2"
	       shift
	       ;;                                                                                                                       # See the comment of option '--in=' to see what's going on here - principle is the same.
			--min-samples=*)
				_arg_minsamples="${_key##--min-samples=}"
				;;				
  		# See the comment of option '--in' to see what's going on here - principle is the same.
			--c2|--clusterid2)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_clusterid="$2"
				shift
				;;
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--clusterid2=*)
				_arg_clusterid="${_key##--clusterid2=}"
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			--c2*)
				_arg_clusterid="${_key##--c2}"
				;;
			# See the comment of option '--in' to see what's going on here - principle is the same.
			-a|--alignlength)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_minlength="$2"
				shift
				;;
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--alignlength=*)
				_arg_minlength="${_key##--alignlength=}"
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			-a*)
				_arg_minlength="${_key##-a}"
				;;
			# See the comment of option '--in' to see what's going on here - principle is the same.
			-d|--maxdiffs)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_maxdiffs="$2"
				shift
				;;
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--maxdiffs=*)
				_arg_maxdiffs="${_key##--maxdiffs=}"
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			-d*)
				_arg_maxdiffs="${_key##-d}"
				;;
			# See the comment of option '--paired' to see what's going on here - principle is the same.
			-h|--help)
				print_help
				exit 0
				;;
			# See the comment of option '-p' to see what's going on here - principle is the same.
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash
# ] <-- needed because of Argbash

#(script stuff)

if [ -z "$_arg_in" ]
then
	_PRINT_HELP=yes die "ERROR: Missing expected parameters: input directory"
fi

logfile=./$_arg_out/"seanome_clusterAll_$(date +%m_%d_%Y_%H-%M-%S).log"
echo "$0 $@" > $logfile
echo "Running 'clusterAll' using "$_arg_threads" threads." >> $logfile
echo "" >> $logfile

#get sample names from directory
popnames=$(ls "./$_arg_in" | grep -v ".log" | sed "s|$_arg_in/||" | sed "s|/:||" | sed "s|.F.fastq||" | sed "s|.R.fastq||" | sort | uniq) 

#remove trailing slashes if present
_arg_in=$(echo "$_arg_in" | sed "s|/$||")
_arg_out=$(echo "$_arg_out" | sed "s|/$||")
mkdir "$_arg_out/ALL"

rm "$_arg_out/ALL/ALL.fasta"
rm "$_arg_out/ALL/ALL.contigs"
rm "$_arg_out/ALL/ALL.mapping"

while read -r line; do
    NAME=$line
    indexPath="$_arg_out/$NAME"

    #TODO: check to see if these files exist first
    cat $indexPath"/"$NAME".fasta" >> "$_arg_out/ALL/ALL.fasta"
    cat $indexPath"/"$NAME".fastq" >> "$_arg_out/ALL/ALL.fastq"
    cat $indexPath"/"$NAME".contigs.out" >> "$_arg_out/ALL/ALL.contigs"
    cat $indexPath"/"$NAME".mapping.out" >> "$_arg_out/ALL/ALL.mapping"

done <<< "$popnames"

NAME='FINAL'
THREADS=$_arg_threads

cd $_arg_out/ALL

#filter by min. sample depth (default=3)
echo -e "\n"; date; echo -e "START filterByDepth.py"
python ./scripts/filterByDepth.py $_arg_mindp
./programs/seqtk/seqtk subseq ALL.contigs ALL.filtered.ids > ALL.filtered.contigs 
echo -e "\n"; date; echo -e "END filterByDepth.py"

#cluster
echo -e "\n"; date; echo -e "START vsearch --cluster_fast iter1"
vsearch --cluster_fast ALL.filtered.contigs --strand plus --id 0.95 \
    --msaout ${NAME}_1.msa --userout ${NAME}_1.out \
    --userfields query+target+caln+qstrand+tstrand --mincols 80 \
    --maxdiffs 10 --threads ${THREADS} >> $logfile
echo -e "\n"; date; echo -e "END vsearch --cluster_fast iter 1"

echo -e "\n"; date; echo -e "START muso.py  -t ${THREADS} -i1 ${NAME}_1.msa -o1 ${NAME}_mod_1.cons -i2 ${NAME}_1.out -o2 ${NAME}_mod_1.out -g 1 -m 3 -n 2000" 
./scripts/muso.py  -t ${THREADS} -i1 ${NAME}_1.msa -o1 ${NAME}_mod_1.cons \
    -i2 ${NAME}_1.out -o2 ${NAME}_mod_1.out -g 3 \
    --problemCtgs problematic_it_1
echo -e "\n"; date; echo -e "END muso.py  -t ${THREADS} -i1 ${NAME}_1.msa -o1 ${NAME}_mod_1.cons -i2 ${NAME}_1.out -o2 ${NAME}_mod_1.out -g 1 -m 3 -n 2000\n" 

echo -e "\n"; date; echo -e "START vsearch --cluster_fast iter2"
vsearch --cluster_fast ${NAME}_mod_1.cons --strand both --id 0.95 --msaout ${NAME}_2.msa --userout ${NAME}_2.out --userfields query+target+caln+qstrand+tstrand --mincols 80 --maxdiffs 10 --threads ${THREADS} >> $logfile
echo -e "\n"; date; echo -e "START vsearch --cluster_fast iter2"

echo -e "\n"; date; echo -e "START muso.py  -t ${THREADS} -i1 ${NAME}_2.msa -o1 ${NAME}.final.contigs -i2 ${NAME}_2.out -o2 ${NAME}.final.out -g 2 -m 3 -n 2000"
./scripts/muso.py  -t ${THREADS} -i1 ${NAME}_2.msa -o1 ${NAME}.final.contigs \
     -i2 ${NAME}_2.out -o2 ${NAME}.final.out -g 4 --problemCtgs problematic_it_2 
echo -e "\n"; date; echo -e "END muso.py  -t ${THREADS} -i1 ${NAME}_2.msa -o1 ${NAME}.final.contigs -i2 ${NAME}_2.out -o2 ${NAME}.final.out -g 2 -m 3 -n 2000\n" 

echo -e "\n"; date; echo -e "START trackOverlaps.py -i1 ${NAME}_mod_1.out  -i2 ${NAME}.final.out  -o ${NAME}.mapping_to_cons" 
./scripts/x.py ${NAME}_mod_1.out   ${NAME}.final.out > ${NAME}.mapping_to_cons
echo -e "\n"; date; echo -e "END trackOverlaps.py -i1 ${NAME}_mod_1.out  -i2 ${NAME}.final.out  -o ${NAME}.mapping_to_cons\n" 

./scripts/final_x.py ALL.filtered.mapping $NAME.mapping_to_cons > ALL_FINAL.mapping_to_cons

#finally, realign and call SNPs
cd $_arg_out/
python ./scripts/realign_callsnps.py $_arg_in $_arg_out $_arg_threads $_arg_mindp $_arg_maxdp $_arg_minper $_arg_mincc $_arg_mincount $_arg_mindepth $_arg_minsamples $_arg_maxmm $_arg_ploidy

#OLD BELOW

# while read -r line; do
# 
#     #figure out parallelization
#     #_arg_threads is max user wants (nproc by default)
#     
#     #run clustering script
#     partialIndexList=$(find "./$_arg_out/$line/" -name "partial_F_[0-9]*.ids")
#     
#     parallel --will-cite -j $_arg_threads bash ./2020_processSample.sh $_arg_in $_arg_out $line {} $_arg_paired $_arg_mixed $_arg_threads $_arg_quality $_arg_percentbases $_arg_clusterid $_arg_minlength $_arg_maxdiffs $_arg_nonambiguous <<< "$partialIndexList" >> $logfile
#     
#     #handle output files
#     mkdir ./$_arg_out/$line"/tmpfiles_"$line
#     cat ./$_arg_out/$line*contigs > ./$_arg_out/$line/$line"contigs.out"
#     cat ./$_arg_out/$line*mapping_to_cons > ./$_arg_out/$line/$line".mapping.out"
#     find ./$_arg_out/$line -type f ! -name "$line*" -exec mv {} ./$_arg_out/$line"/tmpfiles_"$line \; 2> /dev/null
# 
# done <<< "$popnames"
