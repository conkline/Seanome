#!/bin/bash
#
# ARG_OPTIONAL_SINGLE([in],[i],[name of input directory containing raw reads])
# ARG_OPTIONAL_SINGLE([out],[o],[name of output directory])
# ARG_OPTIONAL_SINGLE([c1],[],[sequence expected at cutsite, from first (or only) enzyme],[GATC])
# ARG_OPTIONAL_SINGLE([c2],[],[sequence expected at cutsite, from second enzyme])
# ARG_OPTIONAL_SINGLE([mixed],[m],[.csv detailing paired-end status and enzyme(s) per sample])
# ARG_OPTIONAL_SINGLE([n_index_files],[n],[number of indexed output files per sample],[4])
# ARG_OPTIONAL_SINGLE([hash_length],[l],[length of hash index, in number of nucleotides],[6])
# ARG_OPTIONAL_BOOLEAN([paired],[p],[all reads have forward and reverse files])
# ARG_OPTIONAL_BOOLEAN([keep_strand],[k],[keep reads even if one direction is dropped due to cutsite])
# ARG_OPTIONAL_BOOLEAN([rescue],[r],[rescue reads if cutsite if off by only one base nucleotide])
# ARG_HELP([],[Given an input and output directory, this script indexes and clusters reads in each sample using a hash, or kmer, of specified length. If data has been generated with a single restriction enzyme (e.g. ezRAD), specify cutsite with the "c1" argument. If data has been generated with two restriction enzymes (e.g. ddRAD), you must specify both cutsites with "c1" and "c2". Decreasing the number of indexed output files with "n" may improve accuracy, but increases runtime. Likewise, decreasing the hash length with "l" may improve accuracy, but increase runtime. The optional argument "k" tells Seanome to keep a pair of reads if one is dropped due to ambiguous cutsite; by default both are dropped if one fails. The optional argument "r" tells Seanome to keep reads that differ from the expected cutsite by one nucelotide, allowing for sequencing error.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


# # When called, the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}

# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option()
{
	local first_option all_short_options='ionlkrh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_in=""
_arg_out=""
_arg_mixed="off"
_arg_paired="off"
_arg_threads=$(nproc)
_arg_c1="GATC"
_arg_c2="off"
_arg_n_index_files="4"
_arg_hash_length="6"
_arg_keep_strand="off"
_arg_rescue="off"


# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help()
{
	printf 'Usage: %s [-i|--in <arg>] [-o|--out <arg>] [-m|--mixed <arg>] [-p|--(no-)paired] [--e1 <arg>] [--e2 <arg>] [-f|--n_index_files <arg>] [-l|--hash_length <arg>] [-k|--keep_strand] [-r|--rescue] [-t|--threads <arg>] [-h|--help]\n' "$0"
	printf '\t%s\n' "-i, --in: name of input directory containing raw reads (no default)"
	printf '\t%s\n' "-o, --out: name of output directory (no default)"
	printf '\t%s\n' "-m, --mixed: optional .csv specifying enzymes and paired-end status per sample (no default)"
	printf '\t%s\n' "-p, --paired: samples have both forward and reverse read files (off by default)"
	printf '\t%s\n' "--e1: sequence expected at cutsite, from first (or only) enzyme (default: 'GATC')"
	printf '\t%s\n' "--e2: sequence expected at cutsite, from second enzyme (no default)"
	printf '\t%s\n' "-f, --n_index_files: number of indexed output files per sample (default: '4')"
	printf '\t%s\n' "-l, --hash_length: length of hash index, in number of nucleotides (default: '6')"
	printf '\t%s\n' "-k, --keep_strand, --no-keep_strand: keep reads even if one direction is dropped due to cutsite (off by default)"
	printf '\t%s\n' "-r, --rescue, --no-rescue: rescue reads if cutsite if off by only one base nucleotide (off by default)"
	printf '\t%s\n' "-t, --threads: number of threads to run in parellel (default: # available)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\n%s\n' "Given an input and output directory, this script indexes and clusters reads in each sample using a hash, or kmer, of specified length. If data are paired, use the \"-p\" argument. If data has been generated with a single restriction enzyme (e.g. ezRAD), specify cutsite with the \"--c1\" argument. If data has been generated with two restriction enzymes (e.g. ddRAD), you must specify both cutsites with \"--c1\" and \"--c2\".
	
Decreasing the number of indexed output files with \"-n\" may improve accuracy, but increases runtime. Likewise, decreasing the hash length with \"-l\" may improve accuracy, but increase runtime. The optional argument \"-k\" tells Seanome to keep a pair of reads if one is dropped due to ambiguous cutsite; by default both are dropped if one fails. The optional argument \"-r\" tells Seanome to keep reads that differ from the expected cutsite by one nucelotide, allowing for sequencing error.

If input files use different restriction enzymes and/or are a mix of paired-end and single-end, use the \"-m\" argument and pass in a .csv file with the following format:
SAMPLE,C1,C2,PAIRED
Sample1,GATC,-,yes
Sample2,GATC,TAAT,no
"
}


# The parsing of the command-line
parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			# We support whitespace as a delimiter between option argument and its value.
			# Therefore, we expect the --in or -i value.
			# so we watch for --in and -i.
			# Since we know that we got the long or short option,
			# we just reach out for the next argument to get the value.
			-i|--in)
				test $# -lt 2 && die "Missing value for the argument '$_key'." 1
				_arg_in="$2"
				shift
				;;
			# We support the = as a delimiter between option argument and its value.
			# Therefore, we expect --in=value, so we watch for --in=*
			# For whatever we get, we strip '--in=' using the ${var##--in=} notation
			# to get the argument value
			--in=*)
				_arg_in="${_key##--in=}"
				;;
			# We support getopts-style short arguments grouping,
			# so as -i accepts value, we allow it to be appended to it, so we watch for -i*
			# and we strip the leading -i from the argument string using the ${var##-i} notation.
			-i*)
				_arg_in="${_key##-i}"
				;;
			# See the comment of option '--in' to see what's going on here - principle is the same.
			-o|--out)
				test $# -lt 2 && die "Missing value for the argument '$_key'." 1
				_arg_out="$2"
				shift
				;;
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--out=*)
				_arg_out="${_key##--out=}"
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			-o*)
				_arg_out="${_key##-o}"
				;;
				# See the comment of option '--in' to see what's going on here - principle is the same.
			-m|--mixed)
				test $# -lt 2 && die "Missing value for the argument '$_key'." 1
				_arg_mixed="$2"
				shift
				;;
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--mixed=*)
				_arg_mixed="${_key##--mixed=}"
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			-m*)
				_arg_mixed="${_key##-m}"
				;;
			-t|--threads)
				test $# -lt 2 && die "Missing value for the argument '$_key'." 1
				_arg_threads="$2"
				shift
				;;
			--threads=*)
				_arg_threads="${_key##--threads=}"
				;;
			-t*)
				_arg_threads="${_key##-t}"
				;;	
			# See the comment of option '--in' to see what's going on here - principle is the same.
			--e1)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_c1="$2"
				shift
				;;
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--e1=*)
				_arg_c1="${_key##--e1=}"
				;;
			# See the comment of option '--in' to see what's going on here - principle is the same.
			--e2)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_c2="$2"
				shift
				;;
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--e2=*)
				_arg_c2="${_key##--e2=}"
				;;
			# See the comment of option '--in' to see what's going on here - principle is the same.
			-f|--n_index_files)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_n_index_files="$2"
				shift
				;;
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--n_index_files=*)
				_arg_n_index_files="${_key##--n_index_files=}"
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			-f*)
				_arg_n_index_files="${_key##-f}"
				;;
			# See the comment of option '--in' to see what's going on here - principle is the same.
			-l|--hash_length)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_hash_length="$2"
				shift
				;;
			# See the comment of option '--in=' to see what's going on here - principle is the same.
			--hash_length=*)
				_arg_hash_length="${_key##--hash_length=}"
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			-l*)
				_arg_hash_length="${_key##-l}"
				;;
			# The keep_strand argurment doesn't accept a value,
			# we expect the --keep_strand or -k, so we watch for them.
			-k|--no-keep_strand|--keep_strand)
				_arg_keep_strand="on"
				test "${1:0:5}" = "--no-" && _arg_keep_strand="off"
				;;
			# We support getopts-style short arguments clustering,
			# so as -k doesn't accept value, other short options may be appended to it, so we watch for -k*.
			# After stripping the leading -k from the argument, we have to make sure
			# that the first character that follows coresponds to a short option.
			-k*)
				_arg_keep_strand="on"
				_next="${_key##-k}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-k" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--keep_strand' to see what's going on here - principle is the same.
			-r|--no-rescue|--rescue)
				_arg_rescue="on"
				test "${1:0:5}" = "--no-" && _arg_rescue="off"
				;;
			# See the comment of option '-k' to see what's going on here - principle is the same.
			-r*)
				_arg_rescue="on"
				_next="${_key##-r}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-r" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
				# See the comment of option '--keep_strand' to see what's going on here - principle is the same.
			-p|--no-paired|--paired)
				_arg_paired="on"
				test "${1:0:5}" = "--no-" && _arg_paired="off"
				;;
			# See the comment of option '-k' to see what's going on here - principle is the same.
			-p*)
				_arg_paired="on"
				_next="${_key##-p}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-p" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--keep_strand' to see what's going on here - principle is the same.
			-h|--help)
				print_help
				exit 0
				;;
			# See the comment of option '-k' to see what's going on here - principle is the same.
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash
# ] <-- needed because of Argbash

if [ -z "$_arg_in" ]
then
	_PRINT_HELP=yes die "ERROR: Missing expected parameters: input directory"
fi

logfile=./$_arg_out/"seanome_indexReads_$(date +%m_%d_%Y_%H-%M-%S).log"
echo "$0 $@" > $logfile
echo "Running 'indexReads' using "$_arg_threads" threads." >> $logfile
echo "" >> $logfile

#remove trailing slashes if present
_arg_in=$(echo "$_arg_in" | sed "s|/$||")
_arg_out=$(echo "$_arg_out" | sed "s|/$||")

ls "./$_arg_in" | sed s/\..\.fastq// | sort | uniq | parallel --will-cite -j $_arg_threads "mkdir ./$_arg_out/{}; python ./scripts/indexReadsOverlap.py $_arg_in $_arg_out {} $_arg_paired $_arg_mixed $_arg_n_index_files $_arg_hash_length $_arg_c1 $_arg_c2 $_arg_keep_strand $_arg_rescue $_arg_threads" >> $logfile
